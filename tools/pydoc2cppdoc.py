'''
This takes Python __doc__ strings and writes them out in C++ in a way suitable
for pybind11.

Usage::

    python pydoc2cppdoc.py <module>

This will import the module, extract all the documentation strings and write
a C++ file of string literals to stdout. These literals can be used in your
pybind11 file.

Here is a very simple example:

Suppose you have a module 'example.py' that looks like this::

    """
    Example module documentation.
    """
    class Example:
        """Example class documentation"""
        def __init__(self, *args, **kwargs):
            """Construct an Example."""
            pass

If you run::

    python pydoc2cppdoc.py example.py

It will produce something like this::

    // Auto generated documentation strings
    //       Module: example
    //  Module path: .../example.py
    // Generated by: pydoc2cppdoc.py
    // Generated on: Mon Mar 12 19:24:51 2018
    
    const char *DOCSTRING_example = R"doc_from_python(
    Example module documentation.
    
    )doc_from_python";
    
    const char *DOCSTRING_example_Example = R"doc_from_python(Example class documentation
    )doc_from_python";
    
    const char *DOCSTRING_example_Example___init__ = R"doc_from_python(Construct an Example.
    )doc_from_python";

Save this as a file such as example_docs.h then in your pybind11 file pull in the docstrings::

    #include "example_docs.h"

    PYBIND11_MODULE(cXmlWrite, m) {
        m.doc() = DOCSTRING_example;
        
        py::class_<Example>(m, "Example", DOCSTRING_example_Example)
            .def(py::init<>(),
                 DOCSTRING_example_Example___init__)

For a bigger example run this on the accompanying ExampleDocstring.py thus::

    python pydoc2cppdoc.py example_docstrings.py


Created on 23 Feb 2018

@author: paulross
'''
import builtins
import datetime
import importlib
import inspect
import os
import re
import sys

#: Builtin types to ignore. Retain type type to get our class docstrings.
builtins_special = [_b[1] for _b in inspect.getmembers(builtins) if _b[1] != type]
#: Unique delimiter for string literal names.
cpp_str_delim = 'doc_from_python'
#: Detect special method names.
RE_MAGIC_METH = re.compile(r'__(.+?)__')


def print_doc(doc_str, *args):
    """
    Print out the documentation string as a string literal named from args.
    """
    print('const char *DOCSTRING_{} = R"{}({}'.format('_'.join(args),
                                                      cpp_str_delim,
                                                      doc_str))
    print('){}";'.format(cpp_str_delim))
    print()


def get_doc(obj):
    """
    Returns the documentation or None. Ignore imported modules.
    """
    if type(obj) not in builtins_special and str(type(obj)) != "<class 'module'>":
        return getattr(obj, '__doc__', None) 


def print_member_doc(name, obj):
    """
    Recursively print documentation strings.
    Returns the number of strings written out.
    """
    num = 0
    for member_name, member_obj in sorted(inspect.getmembers(obj)):
        doc = get_doc(member_obj)
        if doc is not None:
            print_doc(doc, name, member_name)
            num += 1
            if RE_MAGIC_METH.match(member_name) is None:
                num += print_member_doc('{}_{}'.format(name, member_name), member_obj)
    return num


def main(module_path):
    """
    Extracts documentation strings from the Python module given as an
    argument and writes them as C++ literal strings to stdout.
    """
    sys.path.append(os.path.dirname(module_path))
    module_name = os.path.splitext(os.path.basename(module_path))[0]
    module = importlib.import_module(module_name)
    print('// Auto generated documentation strings')
    print('//       Module: {}'.format(module_name))
    print('//  Module path: {}'.format(module.__file__))
    print('// Generated by: {}'.format(__file__))
    print('// Generated on: {}'.format(datetime.datetime.now().strftime('%c')))
    print()
    doc_count = 0
    doc = getattr(module, '__doc__', None)
    if doc is not None:
        print_doc(doc, module_name)
        doc_count += 1
    doc_count += print_member_doc(module_name, module)
    print('// Completed {:d} documentation strings from module {}'.format(doc_count, module_name))
    return 0


if __name__ == '__main__':
    """Invocation: python pydoc2cppdoc.py <Python module>
    Example: python pydoc2cppdoc.py ExampleDocstrings.py 
    """
    sys.exit(main(sys.argv[1]))
